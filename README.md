# SimpleBuddySystem
Buddy system的极简实现方式

### Buddy system理论

> 知其然还要知其所以然

Linux引入Buddy system使用必然存在他的必要原因。

Linux基于段页式机制管理物理内存，内存被分割成一个个页框，由多级页表管理。除此之外，由于硬件的约束：

- DMA处理器，只能对RAM的前16MB寻址。
- 32位机器CPU最大寻址空间，只有4GB，对于大容量超过4GB的RAM，无法访问所有的地址空间。

Linux还将物理内存划分为不同的管理区：ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM，每个管理区都有自己的描述符，也有自己的页框分配器，示意图如下：

![](https://cdn.jsdelivr.net/gh/Leo-yang-1020/picRepo/img/20210812203120.png)

对于连续页框组的内存分配请求，是由管理区分配器完成，每个管理区的页框分配是通过伙伴系统算法来实现。内核经常请求和释放单个页框，为了提高性能，每个内存管理区，还定义了一个CPU页框高速缓存，包含一些预选分配的页框。

**伙伴系统算法：**内核为分配一组**连续**的页框而建立的一种健壮、高效的分配策略，这种策略缓解了内存碎片的发生。算法的核心思想：是把所有的空闲页框分组为11个块链表，每个块链表分别包含1、2、4、8、16、...、512、1024个连续页框。举个简单的例子，说明算法的工作过程。

**伙伴系统属于连续内存分配的算法，但是在Linux中的应用，并不是针对于整块大内存，而是对于页框进行分配，在性能与效果上，能够减少外部碎片，并且便于快速分配与回收。**

假设需要256个页框的连续内存，算法先在256个页框的链表中，检查是否还有空闲块，如果有就分配出去。如果没有，算法会找到下一个更大的512页框的链表，如果存在空闲块，内核会把512页框分割成两部分，一半用来分配，另一半插入到256页框的链表中。

至此，我们可以看到，Buddy system在Linux中得到使用的原因。



#### Buddy system的定义，分配，释放

这里给出伙伴的概念，满足以下三个条件的称为伙伴：
1）两个块大小相同；
2）两个块地址连续；
3）两个块必须是同一个大块中分离出来的；



分配的情况：

伙伴系统只会分配为2的幂大小的块（如果是页框，即为2的幂数量的页框）

当需要的分区大小为 2^u-1<s<=2^u 时，会将整个块分配给该进程

简单的话来讲，就是分配一块刚刚好的块，即不大，也不小。

释放合并的情况：

当内存块完成释放后，需要进行紧凑。

紧凑进行的条件是：

- 大小相同
- 地址相邻
- 是从原来同一个块分离出来的



### 简易实现伙伴系统

既然是简易实现，我们就不需要考虑太多空间与时间的效应问题，只抓住最核心的需求：有内存，分配内存，回收内存。

伙伴系统的层次图很像一颗满二叉树，因此，我们自然选择了这样的数据结构去实现分配（满二叉树用数组便可以轻松表示，何乐而不为）

 核心结构体定义：

```c
struct buddy2 {
  unsigned size;//表明管理内存的总单元数
  unsigned longest[1]; //完全二叉树的节点标记，表明对应内存块的空闲单位，长度为1方便扩展
};
```



初始化过程：

```c
struct buddy2* buddy2_new( int size ) {//初始化分配器
  struct buddy2* self;
  unsigned node_size;//节点所拥有的内存大小
  int i;

  if (size < 1 || !IS_POWER_OF_2(size))
    return NULL;

  self = (struct buddy2*)ALLOC( 2 * size * sizeof(unsigned));
  self->size = size;
  node_size = size * 2;

  for (i = 0; i < 2 * size - 1; ++i) {//初始化每一个节点
    if (IS_POWER_OF_2(i+1))
      node_size /= 2;
    self->longest[i] = node_size;
    //初始化操作，向表示满二叉树的数组赋值，例子：size为16 则赋值的数组为[16,8,8,4,4,4,4....]
    //表示节点对应的块的大小
  }
  return self;
}
```

最巧妙的就在于longest数组的使用。该数组相当于是满二叉树，每个节点表示了块的大小。



分配算法：

```c
```

